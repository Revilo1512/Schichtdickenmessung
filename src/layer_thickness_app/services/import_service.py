import csv
from typing import Tuple

from layer_thickness_app.services.database_service import DatabaseService


class ImportService:
    """
    Imports measurement data from a CSV file into the DatabaseService.
    """

    # Define the columns required by the save_measurement method
    REQUIRED_COLUMNS = {'Name', 'Layer', 'RefImage', 'MatImage', 'Shelf', 'Book', 'Page'}

    def __init__(self, db_service: DatabaseService):
        """
        Initializes the import service.

        Args:
            db_service (DatabaseService): An instance of the DatabaseService.
        """
        self.db_service = db_service

    def import_from_csv(self, filepath: str) -> Tuple[int, int]:
        """
        Reads a CSV file and inserts its data into the database.

        This method ignores the 'id' and 'Date' columns from the CSV,
        as new ones will be generated by the database upon insertion.
        It performs type conversion for the 'Layer' column (to float).

        Args:
            filepath (str): The full path to the CSV file to import.

        Returns:
            Tuple[int, int]: A tuple containing (success_count, fail_count).
        """
        print(f"Starting import from {filepath}...")
        success_count = 0
        fail_count = 0

        try:
            with open(filepath, 'r', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)

                if not reader.fieldnames:
                    print(f"Error: CSV file is empty or has no header: {filepath}")
                    return (0, 0)

                # Check if all required columns are in the CSV header
                reader_headers = set(reader.fieldnames)
                if not self.REQUIRED_COLUMNS.issubset(reader_headers):
                    missing = self.REQUIRED_COLUMNS - reader_headers
                    print(f"Error: CSV file is missing required columns: {missing}")
                    return (0, 0) # Fails the entire import

                # Process each row (i=row number for logging)
                for i, row in enumerate(reader, start=2): # start=2 to account for header
                    try:
                        # Build the data dictionary for save_measurement
                        data_to_save = {}
                        for col in self.REQUIRED_COLUMNS:
                            data_to_save[col] = row[col]

                        # --- Data Validation and Type Conversion ---
                        # Convert 'Layer' from string (in CSV) to float (in DB)
                        data_to_save['Layer'] = float(row['Layer'])
                        
                        # Save the validated data
                        new_id = self.db_service.save_measurement(data_to_save)
                        if new_id > -1:
                            success_count += 1
                        else:
                            # save_measurement already prints its own error
                            print(f"Error saving row {i} (database service failed).")
                            fail_count += 1

                    except (ValueError, TypeError):
                        print(f"Error processing row {i}: Invalid data type for 'Layer'. Expected float, got '{row.get('Layer', 'N/A')}'")
                        fail_count += 1
                    except Exception as e:
                        print(f"An unexpected error occurred processing row {i}: {e}")
                        fail_count += 1

        except FileNotFoundError:
            print(f"Error: File not found at {filepath}")
            return (0, 0)
        except Exception as e:
            print(f"Error reading CSV file {filepath}: {e}")
            return (0, 0)

        print(f"Import complete: {success_count} rows succeeded, {fail_count} rows failed.")
        return (success_count, fail_count)